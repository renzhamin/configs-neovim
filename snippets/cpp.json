{
  "king_for": {
    "prefix": "king_for",
    "body": "for(int ${1:i}=${2:0};${1:i}<${3:n};${1:i}++){\n\t${4:}\n}"
  },
  "dr8": {
    "prefix": "dr8",
    "body": "int di[8]={0,0,1,-1,1,-1,1,-1},\n    dj[8]={1,-1,0,0,1,-1,-1,1};"
  },
  "map": {
    "prefix": "map",
    "body": "map<${1:key}, ${2:value}> ${0:mp};"
  },
  "dpairs": {
    "prefix": "dpairs",
    "body": "#define pl pair<ll,ll>\n#define ff first\n#define ss second"
  },
  "forv": {
    "prefix": "forv",
    "body": "for(auto i=${1:arr}.begin();i!=${1:arr}.end();i++){\n}"
  },
  "for": {
    "prefix": "for",
    "body": "for(int i=0;i<n;i++){\n\t$0\n} "
  },
  "dr4": {
    "prefix": "dr4",
    "body": "int di[]={0,0,1,-1},\n\tdj[]={1,-1,0,0};"
  },
  "kfor": {
    "prefix": "kfor",
    "body": "for(int k=0;k<${1:n};k++){\n}"
  },
  "mfor": {
    "prefix": "mfor",
    "body": "for(int i=0;i<${1:m};i++){\n}"
  },
  "bigmod": {
    "prefix": "bigmod",
    "body": "ll BigMod(ll base,ll power,ll mod){\n\tll result=1;\n\twhile(power){\n\t\tif(power&1)\n\t\t\tresult=(result*base)%mod;\n\t\tbase=(base*base)%mod;\n\t\tpower>>=1LL;\n\t}\n\treturn result;\n}"
  },
  "case": {
    "prefix": "case",
    "body": "cout<<\"Case \"<<T++<<\": \";"
  },
  "c++_io": {
    "prefix": "c++_io",
    "body": "#include <bits/stdc++.h>\n#define ll long long\n#define localhost \nusing namespace std;\nint main(){\n#ifdef localhost\n\tfreopen(\"Input.txt\",\"r\",stdin); freopen(\"Output.txt\",\"w\",stdout);\n#endif\n\t${1:}\n}"
  },
  "clockend": {
    "prefix": "clockend",
    "body": "end=clock();\ndouble time=double(end-start)/double(CLOCKS_PER_SEC);\ncout<<setprecision(5)<<fixed<<time<<\"\\n\";"
  },
  "clockstart": {
    "prefix": "clockstart",
    "body": "clock_t start,end;\nstart=clock();"
  },
  "divisorcount": {
    "prefix": "divisorcount",
    "body": "ll countdivisors(ll n){\n\tll c,total=1,N=n;\t\n\tfor(int i=0;primes[i]*primes[i]<=n;++i){\n\t\tif(n%primes[i]==0){\n\t\t\tc=1;\n\t\t\twhile(n%primes[i]==0){\n\t\t\t\tn/=primes[i];\n\t\t\t\tc++;\n\t\t\t}\n\t\t\ttotal*=c;\n\t\t}\n\t}\n\tif(n>1) total<<=1;\n\treturn total;\n}"
  },
  "out": {
    "prefix": "out",
    "body": "cout<<${1:s}<<\"\\n\";"
  },
  "cpp": {
    "prefix": "cpp",
    "body": "#ifdef LOCAL\n#include <dbg.h>\n#else\n#include <bits/stdc++.h>\n#define dbg(...)\n#define dbr(...)\n#define dbs(...)\n#endif\n\n#define ll long long \nusing namespace std;\n\nint main(){\n\t${1:}\n}"
  },
  "dcon": {
    "prefix": "dcon",
    "body": "#define done(x) {cout<<x<<\"\\n\";continue;} "
  },
  "ddarr": {
    "prefix": "ddarr",
    "body": "#define darr(arr,i) cout<<#arr<<\"[\"<<i<<\"] = \"<<arr[i]<<\"\\n\";"
  },
  "dld": {
    "prefix": "dld",
    "body": "#define ld long double"
  },
  "dret": {
    "prefix": "dret",
    "body": "#define done(x) {cout<<x<<\"\\n\";return 0;} "
  },
  "fast": {
    "prefix": "fast",
    "body": "ios_base::sync_with_stdio(0),cin.tie(0);"
  },
  "forone": {
    "prefix": "forone",
    "body": "for(int ${2:i}=1;$2<=${1:n};${3:++$2}){\n}",
    "description": "For Loop"
  },
  "yesno": {
    "prefix": "yesno",
    "body": "cout<<(${1:f}?\"YES\\n\":\"NO\\n\");\t"
  },
  "jofor": {
    "prefix": "jofor",
    "body": "for(int i=1;i<=${1:n};i++) "
  },
  "jfor": {
    "prefix": "jfor",
    "body": "for(int j=0;j<${1:n};j++) "
  },
  "jsfor": {
    "prefix": "jsfor",
    "body": "for(auto &i:${1:arr}) "
  },
  "mod_kmp": {
    "prefix": "mod_kmp",
    "body": "void kmp(string &text,string &pattern){\n    int n=pattern.length(),l=text.length(),lps[n],i,j,match=0;\n    lps[0]=0;\n    //j-----i//\n    for(i=1,j=0;i<n;){\n        if(pattern[j]==pattern[i]) lps[i]=j+1,i++,j++;\n        else {\n            if(j) j=lps[j-1];\n            else lps[i]=0,i++;\n        }\n    }\n    //j---------i//\n    i=0,j=0;\n    while(i<l){\n        if(pattern[j]==text[i])\n            i++,j++;\n        else {\n            if(j) j=lps[j-1];\n            else i++;\n        }\n        if(j==n){\n            j=lps[j-1];\n            match++;\n        }\n    }\n}"
  },
  "mod_lqa": {
    "prefix": "mod_lqa",
    "body": "template<typename T>\nint lqa(T *arr,int n,T value){\n\tint i=upper_bound(arr,arr+n,value)-arr;\n\ti--;\n\treturn (i>=0? i : -1);\n}"
  },
  "memset": {
    "prefix": "memset",
    "body": "memset(${1:vis},${2:0},sizeof(${1:vis}));"
  },
  "mod_mulmod": {
    "prefix": "mod_mulmod",
    "body": "ll mulmod(ll a,ll b,ll mod){\n\tll result = 0; a%=mod;\n\twhile(b){\n\t\tif(b&1) \n\t\t\tresult = (result+a)%mod ;\n\t\ta=(a<<1LL)%mod;\n\t\tb>>=1LL;\n\t}\n\treturn result%mod ;\n}"
  },
  "mod_ncr": {
    "prefix": "mod_ncr",
    "body": "ll mem[102][102];\nll nCr(ll n,ll r){\n\tif(mem[n][r]!=0)\n\t\treturn mem[n][r];\n\tif(n==r || r==0) \n\t\treturn mem[n][r]=1;\n\tif(n-r==1 || r==1)\n\t\treturn mem[n][r]=n;\n\treturn mem[n][r]=nCr(n-1,r-1)+nCr(n-1,r); \n}"
  },
  "nest": {
    "prefix": "nest",
    "body": "for(int i=0;i<n;i++){\n    for(int j=0;j<${1:m};j++){\n    }\n}"
  },
  "pair": {
    "prefix": "pair",
    "body": "pair<int,int>${1:edges}"
  },
  "mod_pascal": {
    "prefix": "mod_pascal",
    "body": "const int mx=150;\nll ncr[mx][mx];\nvoid pascal(int n){\n\tfor(int i=1;i<=n;i++){\n\t\tncr[i][0]=1,ncr[i][1]=i;\n\t\tfor(int j=2;j<=n;j++)\n\t\t\tncr[i][j]=ncr[i-1][j]+ncr[i-1][j-1];\n\t}\t\n}"
  },
  "phi_calc": {
    "prefix": "phi_calc",
    "body": "ll calcphi(ll n){\n\tll val=sqrt(n)+1,s=n;\n\tfor(ll i=2;i<val;++i){\n\t\tif(n%i==0){\n\t\t\ts*=(i-1),s/=i;\n\t\t\twhile(n%i==0) n/=i;\n\t\t}\n\t}\n\tif(n>1) s*=(n-1),s/=n;\n\treturn s;\n}"
  },
  "phi_init": {
    "prefix": "phi_init",
    "body": "const int mx=(int)1e3;\nint phi[mx+1];\nvoid initphi(){\n\tphi[1]=1;\n\tfor(ll i=2;i<=mx;++i){\n\t\tif(!phi[i]){\n\t\t\tphi[i]=i-1;\n\t\t\tfor(ll j=2*i;j<=mx;j+=i){\n\t\t\t\tif(!phi[j]) phi[j]=j;\n\t\t\t\tphi[j]=phi[j]/i*(i-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  "preciseprint": {
    "prefix": "preciseprint",
    "body": "cout<<setprecision(10)<<fixed<<${1:ans}<<\"\\n\";"
  },
  "bgen": {
    "prefix": "bgen",
    "body": "${1:arr}.begin(),${1:arr}.end()"
  },
  "rsort": {
    "prefix": "rsort",
    "body": "sort(${1:arr},${1:arr}+n,greater<ll>());"
  },
  "rfor": {
    "prefix": "rfor",
    "body": "for(int i=${1:n}-1;i>=0;i--){\n}"
  },
  "rjfor": {
    "prefix": "rjfor",
    "body": "for(int i=${1:n}-1;i>=0;i--) "
  },
  "rnjfor": {
    "prefix": "rnjfor",
    "body": "for(int i=${1:n};i>0;i--) "
  },
  "sort": {
    "prefix": "sort",
    "body": "sort(${1:arr},${1:arr}+n);"
  },
  "sorzero": {
    "prefix": "sorzero",
    "body": "(${1:f})?cout<<s<<\"\\n\":cout<<0<<\"\\n\";"
  },
  "len": {
    "prefix": "len",
    "body": "${1:}.length();"
  },
  "take": {
    "prefix": "take",
    "body": "for(int i=0;i<n;i++) cin>>${1:arr}[i];"
  },
  "T--": {
    "prefix": "T--",
    "body": "int t,T=1;cin>>t;\nwhile(t--){\n\t$0\n}"
  },
  "t--": {
    "prefix": "t--",
    "body": "int t;cin>>t;\nwhile(t--){\n\t${1:}\n}"
  },
  "vi": {
    "prefix": "vi",
    "body": "vector<int>${1:arr}"
  },
  "vrsort": {
    "prefix": "vrsort",
    "body": "sort(${1:arr}.rbegin(),${1:arr}.rend());"
  },
  "vsort": {
    "prefix": "vsort",
    "body": "sort(${1:arr}.begin(),${1:arr}.end());"
  },
  "mod_bigint": {
    "prefix": "mod_bigint",
    "body": "struct Bigint {\n\tstring a;\n\tint sign;\n\tBigint(){}\n\tvoid operator = (string b) {\n\t\ta= (b[0]=='-' ? b.substr(1) : b);\n\t\treverse(a.begin(), a.end());\n\t\t(*this).Remove0(b[0]=='-' ? -1 : 1);\n\t}\n\tBigint(string x) {(*this)=x;}\n\tBigint(ll x) {(*this)=to_string(x);}\n\tvoid operator = (ll x){*this=to_string(x);}\n\tchar operator[](int i){return a[i];}\n\tint size() {return a.size();}\n\tBigint inverseSign() {sign*=-1; return (*this);}\n\tBigint Remove0(int newSign) {\n\t\tsign = newSign;\n\t\tfor(int i=a.size()-1; i>0 && a[i]=='0'; i--) a.pop_back();\n\t\tif(a.size()==1 && a[0]=='0') sign=1;\n\t\treturn (*this);\n\t}\n\tbool operator == (Bigint x) {return sign==x.sign && a==x.a;}\n\tbool operator == (string x) {return *this==Bigint(x);}\n\tbool operator == (ll x)     {return *this==Bigint(x);}\n\tbool operator != (Bigint x) {return !(*this==x);}\n\tbool operator != (string x) {return !(*this==x);}\n\tbool operator != (ll x)     {return !(*this==x);}\n\tbool operator < (Bigint b) {\n\t\tif (sign!=b.sign) return sign<b.sign;\n\t\tif(a.size()!=b.size()) return a.size()*sign<b.size()*sign;\n\t\tfor(int i=a.size()-1; i>=0; i--)\n\t\t\tif(a[i] != b[i]) return a[i]<b[i];\n\t\treturn false;\n\t}\n\tbool operator <  (string x) {return *this<Bigint(x);}\n\tbool operator <  (ll x)     {return *this<Bigint(x);}\n\tbool operator <= (Bigint b) {return *this==b || *this<b;}\n\tbool operator <= (string b) {return *this==b || *this<b;}\n\tbool operator <= (ll b)     {return *this==b || *this<b;}\n\tbool operator >  (Bigint b) {return !(*this==b || *this<b);}\n\tbool operator >  (string x) {return !(*this==x || *this<x);}\n\tbool operator >  (ll b)     {return !(*this==b || *this<b);}\n\tbool operator >= (Bigint b) {return *this==b || *this>b;}\n\tbool operator >= (string b) {return *this==b || *this>b;}\n\tbool operator >= (ll b)     {return *this==b || *this>b;}\n\tBigint operator + (Bigint b) {\n\t\tif(sign != b.sign) return (*this)-b.inverseSign();\n\t\tBigint sum;\n\t\tfor(int i=0, carry=0; i<a.size() || i<b.size() || carry; i++){\n\t\t\tif (i<a.size()) carry+=a[i]-'0';\n\t\t\tif (i<b.size()) carry+=b[i]-'0';\n\t\t\tsum.a += (carry % 10 + 48);\n\t\t\tcarry /= 10;\n\t\t}\n\t\treturn sum.Remove0(sign);\n\t}\n\tBigint operator +  (string x) {return *this+Bigint(x);}\n\tBigint operator +  (ll x)     {return *this+Bigint(x);}\n\tBigint operator ++ (int) {*this+=1; return *this-1;}\n\tBigint operator ++ ()    {*this+=1; return *this;}\n\tvoid operator += (Bigint x) {*this = *this+x;}\n\tvoid operator += (string x) {*this = *this+x;}\n\tvoid operator += (ll x)     {*this = *this+x;}\n\tBigint operator - ( Bigint b ) {\n\t\tif(sign != b.sign) return (*this)+b.inverseSign();\n\t\tif(*this < b) return (b - *this).inverseSign();\n\t\tBigint sub;\n\t\tfor(int i=0,borrow=0; i<a.size(); i++) {\n\t\t\tborrow = a[i]-borrow-(i<b.size() ? b.a[i] : '0');\n\t\t\tsub.a += borrow>=0 ? borrow+'0' : borrow + 58;\n\t\t\tborrow = borrow>=0 ? 0:1;\n\t\t}\n\t\treturn sub.Remove0(sign);\n\t}\n\tBigint operator - (string x) {return *this-Bigint(x);}\n\tBigint operator - (ll x)     {return *this-Bigint(x);}\n\tBigint operator -- (int) {*this-=1; return *this+1;}\n\tBigint operator -- ()    {*this-=1; return *this;}\n\tvoid operator -= (Bigint x) {*this = *this-x;}\n\tvoid operator -= (string x) {*this = *this-x;}\n\tvoid operator -= (ll x)     {*this = *this-x;}\n\tBigint operator * (Bigint b) {\n\t\tBigint mult(\"0\");\n\t\tfor(int i=0, k=a[i]; i<a.size(); i++, k=a[i]) {\n\t\t\twhile(k-- -'0') mult=mult+b;\n\t\t\tb.a.insert(b.a.begin(),'0');\n\t\t}\n\t\treturn mult.Remove0(sign * b.sign);\n\t}\n\tBigint operator * (string x) {return *this*Bigint(x);}\n\tBigint operator * (ll x)     {return *this*Bigint(x);}\n\tvoid operator *= (Bigint x) {*this = *this*x;}\n\tvoid operator *= (string x) {*this = *this*x;}\n\tvoid operator *= (ll x)     {*this = *this*x;}\n\tBigint operator / (Bigint b) {\n\t\tif(b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0');\n\t\tBigint c(\"0\"), d;\n\t\tfor(int j=0; j<a.size(); j++) d.a += \"0\";\n\t\tint dSign = sign*b.sign; b.sign=1;\n\t\tfor(int i=a.size()-1; i>=0; i--) {\n\t\t\tc.a.insert(c.a.begin(),'0');\n\t\t\tc=c+a.substr(i,1);\n\t\t\twhile(!(c<b)) c=c-b, d.a[i]++;\n\t\t}\n\t\treturn d.Remove0(dSign);\n\t}\n\tBigint operator / (string x) {return *this/Bigint(x);}\n\tBigint operator / (ll x)     {return *this/Bigint(x);}\n\tvoid operator /= (Bigint x) {*this = *this/x;}\n\tvoid operator /= (string x) {*this = *this/x;}\n\tvoid operator /= (ll x)     {*this = *this/x;}\n\tBigint operator % (Bigint b) {\n\t\tif( b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0') ;\n\t\tBigint c(\"0\");\n\t\tint cSign = sign*b.sign; b.sign=1;\n\t\tfor( int i=a.size()-1; i>=0; i-- ) {\n\t\t\tc.a.insert( c.a.begin(),'0');\n\t\t\tc = c+a.substr(i,1);\n\t\t\twhile(!(c<b)) c=c-b;\n\t\t}\n\t\treturn c.Remove0(cSign);\n\t}\n\tBigint operator % (string x) {return *this%Bigint(x);}\n\tBigint operator % (ll x)     {return *this%Bigint(x);}\n\tvoid operator %= (Bigint x) {*this = *this%x;}\n\tvoid operator %= (string x) {*this = *this%x;}\n\tvoid operator %= (ll x)     {*this = *this%x;}\n\tvoid print() {\n\t\tif(sign==-1) putchar('-');\n\t\tfor(int i=a.size()-1; i>=0; i--) putchar(a[i]);\n\t}\n\tfriend istream& operator >>(istream &in,Bigint &x){\n\t\tstring s; in>>s; x=s; return in;\n\t}\n\tfriend ostream& operator <<(ostream &out,Bigint &x){\n\t\tif(x.sign==-1) putchar('-');\n\t\tfor(int i=x.size()-1; i>=0; i--)\n\t\t\tputchar(x[i]);\n\t\treturn out;\n\t}\n\tfriend Bigint pow(Bigint base,Bigint pw){\n\t\tBigint ans=1;\n\t\twhile(pw!=0){\n\t\t\tif(pw%2 !=0) ans*=base;\n\t\t\tbase*=base, pw/=2;\n\t\t}\n\t\treturn ans;\n\t}\n\tfriend Bigint pow(Bigint a, Bigint b,Bigint mod) {\n\t\tif (b==0) return Bigint(1);\n\t\tBigint tmp=pow(a,b/2,mod);\n\t\tif ((b%2)==0) return (tmp*tmp)%mod;\n\t\telse return (((tmp*tmp)%mod)*a)%mod;\n\t}\n\tfriend Bigint sqrt(Bigint x) {\n\t\tBigint ans=x,tmp=(x+1)/2;\n\t\twhile (tmp<ans) ans=tmp, tmp=(tmp+x/tmp)/2;\n\t\treturn ans;\n\t}\n\tfriend Bigint gcd(Bigint a,Bigint b){\n\t\treturn a%b==0 ? b : gcd(b, a%b);\n\t}\n\tfriend Bigint lcm(Bigint a,Bigint b){\n\t\treturn a/gcd(a,b);\n\t}\n};"
  },
  "i128_cpp": {
    "prefix": "i128_cpp",
    "body": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\n__int128 read();\nvoid print(__int128);\n\n\nint main(){\n    $0\n}\n\n\n\n\n\n\n\n__int128 read() {\n    __int128 x = 0, f = 1;\n    char ch = cin.get();\n    while (ch < '0' || ch > '9') {\n        if (ch == '-') f = -1;\n        ch = cin.get();\n    }\n    while (ch >= '0' && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = cin.get();\n    }\n    return x * f;\n}\n\nvoid print(__int128 x) {\n    if (x < 0) {\n        cout<<'-';\n        x = -x;\n    }\n    if (x > 9) print(x / 10);\n    char r=x%10+'0';\n    cout<<r;\n}"
  },
  "i128": {
    "prefix": "i128",
    "body": "__int128 read() {\n    __int128 x = 0, f = 1;\n    char ch = cin.get();\n    while (ch < '0' || ch > '9') {\n        if (ch == '-') f = -1;\n        ch = cin.get();\n    }\n    while (ch >= '0' && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = cin.get();\n    }\n    return x * f;\n}\n\nvoid print(__int128 x) {\n    if (x < 0) {\n        cout<<'-';\n        x = -x;\n    }\n    if (x > 9) print(x / 10);\n    char r=x%10+'0';\n    cout<<r;\n}"
  },
  "mod_sieve": {
    "prefix": "mod_sieve",
    "body": "const int mx=(int)1e6;\nbool isprime[mx+1]; \nint primes[78600],primeno=0; //78600 for 1e6,664700 for 1e7,6303400 for 1e7+1e8\n\nvoid sieve(){\n    memset(isprime,1,sizeof(isprime));\n    int n=sqrt(mx)+1;\n    isprime[0]=isprime[1]=0;\n    for(int i=2;i<=n;i++){\n        if(isprime[i])\n            for(int j=i*i;j<=mx;j+=i)\n                isprime[j]=0;        \n    }\n    for(int i=2;i<=mx;i++) if(isprime[i]) primes[primeno++]=i; \n}"
  },
  "grid_dfs": {
    "prefix": "grid_dfs",
    "body": "void dfs(int px,int py){\n    vis[px][py]=1;\n    for(int i=0;i<4;i++){\n        x=px+di[i],y=py+dj[i];\n        if(x>=n || x<0 || y>=m || y<0 || vis[x][y] || grid[x][y]==${1:'#'})\n            continue;\n        dfs(x,y);\n    } \n}"
  },
  "mod_floydWarshall": {
    "prefix": "mod_floydWarshall",
    "body": "#define nfor for(int i=0;i<mx;i++)for(int j=0;j<mx;j++)\n#define reset nfor d[i][j]=INT_MAX;\n#define reset_path nfor path[i][j]=i;\n#define mx 101\n\nll u,v,w,tmp,d[mx][mx];\n\nvoid floydWarshall(int N){\n    for(int k=1;k<=N;k++){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tfor(int j=1;j<=N;j++){\n                tmp = d[i][k]+d[k][j];\n\t\t\t\tif(tmp<d[i][j]){\n\t\t\t\t\td[i][j] = tmp;\n\t\t\t\t}\n            } \n        }\n    }\n}\n"
  },
  "mod_bellmanFord": {
    "prefix": "mod_bellmanFord",
    "body": "#define MX INT_MAX\n#define relax(x) for(int i=0;i<m;i++){if(d[E[i].u]==MX) continue;\\\n    tmp = d[E[i].u]+E[i].w; if(tmp<d[E[i].v]){x} }\n\nconst int Nmx=1e2+1;\nconst int Emx=Nmx*Nmx;\n\nstruct edge{\n    ll u,v,w;\n}E[Emx];\n\nll d[Nmx],n,m,u,v,w,q,tmp;\nbool negCycle;\n\nvoid bellmanFord(int source,bool checkCycle=0){\n    for(int i=0;i<=n;i++) d[i]=MX;\n    d[source]=0;\n\n    for(int j=1;j<n;j++){\n        relax( d[E[i].v] = tmp; )\n    }\n\n    if(!checkCycle) return;\n\n    negCycle=0;\n    relax( negCycle=1; break; )\n}\n"
  },
  "mod_djikstra": {
    "prefix": "mod_djikstra",
    "body": "#define inf 1e17\nconst int mx=1e5+1;\n\nstruct node {\n    ll V,W;\n    bool operator < (const node &a ) const{\n        return a.W < W;\n    }\n};\n\nll d[mx];\nvector<node>adj[mx];\nbool vis[mx];\n\nvoid djikstra(int start,int n){\n    fill(d,d+n+1,inf);\n    memset(vis,0,sizeof(vis));\n    priority_queue<node>q;\n    q.push({start,0});\n    d[start]=0;\n    ll u,w,v,tmp;\n    while(!q.empty()){\n        u=q.top().V;\n        w=q.top().W; \n        q.pop();\n        if(vis[u]) continue; \n        vis[u]=1;\n        for(auto &[v,W]:adj[u]){\n            if(vis[v]) continue;\n            tmp = w + W; \n            if(tmp < d[v]){\n                d[v] = tmp;\n                q.push({v,tmp});\n            }\n        }\n    }\n}\n\n"
  }
}