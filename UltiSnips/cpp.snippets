snippet king_for
for(int ${1:i}=${2:0};${1:i}<${3:n};${1:i}++){
	${4:}
}
endsnippet


snippet dr8
int di[8]={0,0,1,-1,1,-1,1,-1},
    dj[8]={1,-1,0,0,1,-1,-1,1};
endsnippet


snippet map
map<${1:key}, ${2:value}> ${0:mp};
endsnippet


snippet dpairs
#define pl pair<ll,ll>
#define ff first
#define ss second
endsnippet


snippet forv
for(auto i=${1:arr}.begin();i!=${1:arr}.end();i++){
}
endsnippet


snippet for
for(int i=0;i<n;i++){
	$0
} 
endsnippet



snippet dr4
int di[]={0,0,1,-1},
	dj[]={1,-1,0,0};
endsnippet



snippet kfor
for(int k=0;k<${1:n};k++){
}
endsnippet


snippet mfor
for(int i=0;i<${1:m};i++){
}
endsnippet



snippet bigmod
ll BigMod(ll base,ll power,ll mod){
	ll result=1;
	while(power){
		if(power&1)
			result=(result*base)%mod;
		base=(base*base)%mod;
		power>>=1LL;
	}
	return result;
}
endsnippet



snippet case
cout<<"Case "<<T++<<": ";
endsnippet



snippet c++_io
#include <bits/stdc++.h>
#define ll long long
#define localhost 
using namespace std;
int main(){
#ifdef localhost
	freopen("Input.txt","r",stdin); freopen("Output.txt","w",stdout);
#endif
	${1:}
}
endsnippet



snippet clockend
end=clock();
double time=double(end-start)/double(CLOCKS_PER_SEC);
cout<<setprecision(5)<<fixed<<time<<"\n";
endsnippet



snippet clockstart
clock_t start,end;
start=clock();
endsnippet



snippet divisorcount
ll countdivisors(ll n){
	ll c,total=1,N=n;	
	for(int i=0;primes[i]*primes[i]<=n;++i){
		if(n%primes[i]==0){
			c=1;
			while(n%primes[i]==0){
				n/=primes[i];
				c++;
			}
			total*=c;
		}
	}
	if(n>1) total<<=1;
	return total;
}
endsnippet



snippet out
cout<<${1:s}<<"\n";
endsnippet



snippet cpp
#ifdef LOCAL
#include <dbg.h>
#else
#include <bits/stdc++.h>
#define dbg(...)
#define sdbg(...)
#endif

#define ll long long 
using namespace std;

int main(){
	${1:}
}
endsnippet



snippet dcon
#define done(x) {cout<<x<<"\n";continue;} 
endsnippet



snippet ddarr
#define darr(arr,i) cout<<#arr<<"["<<i<<"] = "<<arr[i]<<"\n";
endsnippet



snippet dld
#define ld long double
endsnippet



snippet dret
#define done(x) {cout<<x<<"\n";return 0;} 
endsnippet



snippet fast
ios_base::sync_with_stdio(0),cin.tie(0);
endsnippet



snippet forone "For Loop"
for(int ${2:i}=1;$2<=${1:n};${3:++$2}){
}
endsnippet



snippet yesno
cout<<(${1:f}?"YES\n":"NO\n");	
endsnippet



snippet jofor
for(int i=1;i<=${1:n};i++) 
endsnippet



snippet jfor
for(int j=0;j<${1:n};j++) 
endsnippet



snippet jsfor
for(auto &i:${1:arr}) 
endsnippet



snippet mod_kmp
void kmp(string &text,string &pattern){
    int n=pattern.length(),l=text.length(),lps[n],i,j,match=0;
    lps[0]=0;
    //j-----i//
    for(i=1,j=0;i<n;){
        if(pattern[j]==pattern[i]) lps[i]=j+1,i++,j++;
        else {
            if(j) j=lps[j-1];
            else lps[i]=0,i++;
        }
    }
    //j---------i//
    i=0,j=0;
    while(i<l){
        if(pattern[j]==text[i])
            i++,j++;
        else {
            if(j) j=lps[j-1];
            else i++;
        }
        if(j==n){
            j=lps[j-1];
            match++;
        }
    }
}
endsnippet



snippet mod_lqa
template<typename T>
int lqa(T *arr,int n,T value){
	int i=upper_bound(arr,arr+n,value)-arr;
	i--;
	return (i>=0? i : -1);
}
endsnippet



snippet memset
memset(${1:vis},${2:0},sizeof(${1:vis}));
endsnippet



snippet mod_mulmod
ll mulmod(ll a,ll b,ll mod){
	ll result = 0; a%=mod;
	while(b){
		if(b&1) 
			result = (result+a)%mod ;
		a=(a<<1LL)%mod;
		b>>=1LL;
	}
	return result%mod ;
}
endsnippet



snippet mod_ncr
ll mem[102][102];
ll nCr(ll n,ll r){
	if(mem[n][r]!=0)
		return mem[n][r];
	if(n==r || r==0) 
		return mem[n][r]=1;
	if(n-r==1 || r==1)
		return mem[n][r]=n;
	return mem[n][r]=nCr(n-1,r-1)+nCr(n-1,r); 
}
endsnippet



snippet nest
for(int i=0;i<n;i++){
    for(int j=0;j<${1:m};j++){
    }
}
endsnippet



snippet pair
pair<int,int>${1:edges}
endsnippet



snippet mod_pascal
const int mx=150;
ll ncr[mx][mx];
void pascal(int n){
	for(int i=1;i<=n;i++){
		ncr[i][0]=1,ncr[i][1]=i;
		for(int j=2;j<=n;j++)
			ncr[i][j]=ncr[i-1][j]+ncr[i-1][j-1];
	}	
}
endsnippet



snippet phi_calc
ll calcphi(ll n){
	ll val=sqrt(n)+1,s=n;
	for(ll i=2;i<val;++i){
		if(n%i==0){
			s*=(i-1),s/=i;
			while(n%i==0) n/=i;
		}
	}
	if(n>1) s*=(n-1),s/=n;
	return s;
}
endsnippet



snippet phi_init
const int mx=(int)1e3;
int phi[mx+1];
void initphi(){
	phi[1]=1;
	for(ll i=2;i<=mx;++i){
		if(!phi[i]){
			phi[i]=i-1;
			for(ll j=2*i;j<=mx;j+=i){
				if(!phi[j]) phi[j]=j;
				phi[j]=phi[j]/i*(i-1);
			}
		}
	}
}
endsnippet



snippet preciseprint
cout<<setprecision(10)<<fixed<<${1:ans}<<"\n";
endsnippet



snippet bgen
${1:arr}.begin(),${1:arr}.end()
endsnippet



snippet rsort
sort(${1:arr},${1:arr}+n,greater<ll>());
endsnippet



snippet rfor
for(int i=${1:n}-1;i>=0;i--){
}
endsnippet



snippet rjfor
for(int i=${1:n}-1;i>=0;i--) 
endsnippet



snippet rnjfor
for(int i=${1:n};i>0;i--) 
endsnippet



snippet sort
sort(${1:arr},${1:arr}+n);
endsnippet



snippet sorzero
(${1:f})?cout<<s<<"\n":cout<<0<<"\n";
endsnippet



snippet len
${1:}.length();
endsnippet



snippet take
for(int i=0;i<n;i++) cin>>${1:arr}[i];
endsnippet



snippet T--
int t,T=1;cin>>t;
while(t--){
	$0
}
endsnippet



snippet t--
int t;cin>>t;
while(t--){
	${1:}
}
endsnippet



snippet vi
vector<int>${1:arr}
endsnippet



snippet vrsort
sort(${1:arr}.rbegin(),${1:arr}.rend());
endsnippet



snippet vsort
sort(${1:arr}.begin(),${1:arr}.end());
endsnippet



snippet mod_bigint
struct Bigint {
	string a;
	int sign;
	Bigint(){}
	void operator = (string b) {
		a= (b[0]=='-' ? b.substr(1) : b);
		reverse(a.begin(), a.end());
		(*this).Remove0(b[0]=='-' ? -1 : 1);
	}
	Bigint(string x) {(*this)=x;}
	Bigint(ll x) {(*this)=to_string(x);}
	void operator = (ll x){*this=to_string(x);}
	char operator[](int i){return a[i];}
	int size() {return a.size();}
	Bigint inverseSign() {sign*=-1; return (*this);}
	Bigint Remove0(int newSign) {
		sign = newSign;
		for(int i=a.size()-1; i>0 && a[i]=='0'; i--) a.pop_back();
		if(a.size()==1 && a[0]=='0') sign=1;
		return (*this);
	}
	bool operator == (Bigint x) {return sign==x.sign && a==x.a;}
	bool operator == (string x) {return *this==Bigint(x);}
	bool operator == (ll x)     {return *this==Bigint(x);}
	bool operator != (Bigint x) {return !(*this==x);}
	bool operator != (string x) {return !(*this==x);}
	bool operator != (ll x)     {return !(*this==x);}
	bool operator < (Bigint b) {
		if (sign!=b.sign) return sign<b.sign;
		if(a.size()!=b.size()) return a.size()*sign<b.size()*sign;
		for(int i=a.size()-1; i>=0; i--)
			if(a[i] != b[i]) return a[i]<b[i];
		return false;
	}
	bool operator <  (string x) {return *this<Bigint(x);}
	bool operator <  (ll x)     {return *this<Bigint(x);}
	bool operator <= (Bigint b) {return *this==b || *this<b;}
	bool operator <= (string b) {return *this==b || *this<b;}
	bool operator <= (ll b)     {return *this==b || *this<b;}
	bool operator >  (Bigint b) {return !(*this==b || *this<b);}
	bool operator >  (string x) {return !(*this==x || *this<x);}
	bool operator >  (ll b)     {return !(*this==b || *this<b);}
	bool operator >= (Bigint b) {return *this==b || *this>b;}
	bool operator >= (string b) {return *this==b || *this>b;}
	bool operator >= (ll b)     {return *this==b || *this>b;}
	Bigint operator + (Bigint b) {
		if(sign != b.sign) return (*this)-b.inverseSign();
		Bigint sum;
		for(int i=0, carry=0; i<a.size() || i<b.size() || carry; i++){
			if (i<a.size()) carry+=a[i]-'0';
			if (i<b.size()) carry+=b[i]-'0';
			sum.a += (carry % 10 + 48);
			carry /= 10;
		}
		return sum.Remove0(sign);
	}
	Bigint operator +  (string x) {return *this+Bigint(x);}
	Bigint operator +  (ll x)     {return *this+Bigint(x);}
	Bigint operator ++ (int) {*this+=1; return *this-1;}
	Bigint operator ++ ()    {*this+=1; return *this;}
	void operator += (Bigint x) {*this = *this+x;}
	void operator += (string x) {*this = *this+x;}
	void operator += (ll x)     {*this = *this+x;}
	Bigint operator - ( Bigint b ) {
		if(sign != b.sign) return (*this)+b.inverseSign();
		if(*this < b) return (b - *this).inverseSign();
		Bigint sub;
		for(int i=0,borrow=0; i<a.size(); i++) {
			borrow = a[i]-borrow-(i<b.size() ? b.a[i] : '0');
			sub.a += borrow>=0 ? borrow+'0' : borrow + 58;
			borrow = borrow>=0 ? 0:1;
		}
		return sub.Remove0(sign);
	}
	Bigint operator - (string x) {return *this-Bigint(x);}
	Bigint operator - (ll x)     {return *this-Bigint(x);}
	Bigint operator -- (int) {*this-=1; return *this+1;}
	Bigint operator -- ()    {*this-=1; return *this;}
	void operator -= (Bigint x) {*this = *this-x;}
	void operator -= (string x) {*this = *this-x;}
	void operator -= (ll x)     {*this = *this-x;}
	Bigint operator * (Bigint b) {
		Bigint mult("0");
		for(int i=0, k=a[i]; i<a.size(); i++, k=a[i]) {
			while(k-- -'0') mult=mult+b;
			b.a.insert(b.a.begin(),'0');
		}
		return mult.Remove0(sign * b.sign);
	}
	Bigint operator * (string x) {return *this*Bigint(x);}
	Bigint operator * (ll x)     {return *this*Bigint(x);}
	void operator *= (Bigint x) {*this = *this*x;}
	void operator *= (string x) {*this = *this*x;}
	void operator *= (ll x)     {*this = *this*x;}
	Bigint operator / (Bigint b) {
		if(b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0');
		Bigint c("0"), d;
		for(int j=0; j<a.size(); j++) d.a += "0";
		int dSign = sign*b.sign; b.sign=1;
		for(int i=a.size()-1; i>=0; i--) {
			c.a.insert(c.a.begin(),'0');
			c=c+a.substr(i,1);
			while(!(c<b)) c=c-b, d.a[i]++;
		}
		return d.Remove0(dSign);
	}
	Bigint operator / (string x) {return *this/Bigint(x);}
	Bigint operator / (ll x)     {return *this/Bigint(x);}
	void operator /= (Bigint x) {*this = *this/x;}
	void operator /= (string x) {*this = *this/x;}
	void operator /= (ll x)     {*this = *this/x;}
	Bigint operator % (Bigint b) {
		if( b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0') ;
		Bigint c("0");
		int cSign = sign*b.sign; b.sign=1;
		for( int i=a.size()-1; i>=0; i-- ) {
			c.a.insert( c.a.begin(),'0');
			c = c+a.substr(i,1);
			while(!(c<b)) c=c-b;
		}
		return c.Remove0(cSign);
	}
	Bigint operator % (string x) {return *this%Bigint(x);}
	Bigint operator % (ll x)     {return *this%Bigint(x);}
	void operator %= (Bigint x) {*this = *this%x;}
	void operator %= (string x) {*this = *this%x;}
	void operator %= (ll x)     {*this = *this%x;}
	void print() {
		if(sign==-1) putchar('-');
		for(int i=a.size()-1; i>=0; i--) putchar(a[i]);
	}
	friend istream& operator >>(istream &in,Bigint &x){
		string s; in>>s; x=s; return in;
	}
	friend ostream& operator <<(ostream &out,Bigint &x){
		if(x.sign==-1) putchar('-');
		for(int i=x.size()-1; i>=0; i--)
			putchar(x[i]);
		return out;
	}
	friend Bigint pow(Bigint base,Bigint pw){
		Bigint ans=1;
		while(pw!=0){
			if(pw%2 !=0) ans*=base;
			base*=base, pw/=2;
		}
		return ans;
	}
	friend Bigint pow(Bigint a, Bigint b,Bigint mod) {
		if (b==0) return Bigint(1);
		Bigint tmp=pow(a,b/2,mod);
		if ((b%2)==0) return (tmp*tmp)%mod;
		else return (((tmp*tmp)%mod)*a)%mod;
	}
	friend Bigint sqrt(Bigint x) {
		Bigint ans=x,tmp=(x+1)/2;
		while (tmp<ans) ans=tmp, tmp=(tmp+x/tmp)/2;
		return ans;
	}
	friend Bigint gcd(Bigint a,Bigint b){
		return a%b==0 ? b : gcd(b, a%b);
	}
	friend Bigint lcm(Bigint a,Bigint b){
		return a/gcd(a,b);
	}
};
endsnippet


snippet i128_cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
__int128 read();
void print(__int128);


int main(){
    $0
}







__int128 read() {
    __int128 x = 0, f = 1;
    char ch = cin.get();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = cin.get();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = cin.get();
    }
    return x * f;
}

void print(__int128 x) {
    if (x < 0) {
        cout<<'-';
        x = -x;
    }
    if (x > 9) print(x / 10);
    char r=x%10+'0';
    cout<<r;
}
endsnippet



snippet i128
__int128 read() {
    __int128 x = 0, f = 1;
    char ch = cin.get();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = cin.get();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = cin.get();
    }
    return x * f;
}

void print(__int128 x) {
    if (x < 0) {
        cout<<'-';
        x = -x;
    }
    if (x > 9) print(x / 10);
    char r=x%10+'0';
    cout<<r;
}
endsnippet



snippet mod_sieve
const int mx=(int)1e6;
bool isprime[mx+1]; 
int primes[78600],primeno=0; //78600 for 1e6,664700 for 1e7,6303400 for 1e7+1e8

void sieve(){
    memset(isprime,1,sizeof(isprime));
    int n=sqrt(mx)+1;
    isprime[0]=isprime[1]=0;
    for(int i=2;i<=n;i++){
        if(isprime[i])
            for(int j=i*i;j<=mx;j+=i)
                isprime[j]=0;        
    }
    for(int i=2;i<=mx;i++) if(isprime[i]) primes[primeno++]=i; 
}
endsnippet



snippet grid_dfs
void dfs(int px,int py){
    vis[px][py]=1;
    for(int i=0;i<4;i++){
        x=px+di[i],y=py+dj[i];
        if(x>=n || x<0 || y>=m || y<0 || vis[x][y] || grid[x][y]==${1:'#'})
            continue;
        dfs(x,y);
    } 
}
endsnippet

snippet mod_floydWarshall
#define nfor for(int i=0;i<mx;i++)for(int j=0;j<mx;j++)
#define reset nfor d[i][j]=INT_MAX;
#define reset_path nfor path[i][j]=i;
#define mx 101

ll u,v,w,tmp,d[mx][mx];

void floydWarshall(int N){
    for(int k=1;k<=N;k++){
		for(int i=1;i<=N;i++){
			for(int j=1;j<=N;j++){
                tmp = d[i][k]+d[k][j];
				if(tmp<d[i][j]){
					d[i][j] = tmp;
				}
            } 
        }
    }
}

endsnippet


snippet mod_bellmanFord
#define MX INT_MAX
#define relax(x) for(int i=0;i<m;i++){if(d[E[i].u]==MX) continue;\
    tmp = d[E[i].u]+E[i].w; if(tmp<d[E[i].v]){x} }

const int Nmx=1e2+1;
const int Emx=Nmx*Nmx;

struct edge{
    ll u,v,w;
}E[Emx];

ll d[Nmx],n,m,u,v,w,q,tmp;
bool negCycle;

void bellmanFord(int source,bool checkCycle=0){
    for(int i=0;i<=n;i++) d[i]=MX;
    d[source]=0;

    for(int j=1;j<n;j++){
        relax( d[E[i].v] = tmp; )
    }

    if(!checkCycle) return;

    negCycle=0;
    relax( negCycle=1; break; )
}

endsnippet


snippet mod_djikstra
#define inf 1e17
const int mx=1e5+1;

struct node {
    ll V,W;
    bool operator < (const node &a ) const{
        return a.W < W;
    }
};

ll d[mx];
vector<node>adj[mx];
bool vis[mx];

void djikstra(int start,int n){
    fill(d,d+n+1,inf);
    memset(vis,0,sizeof(vis));
    priority_queue<node>q;
    q.push({start,0});
    d[start]=0;
    ll u,w,v,tmp;
    while(!q.empty()){
        u=q.top().V;
        w=q.top().W; 
        q.pop();
        if(vis[u]) continue; 
        vis[u]=1;
        for(auto &[v,W]:adj[u]){
            if(vis[v]) continue;
            tmp = w + W; 
            if(tmp < d[v]){
                d[v] = tmp;
                q.push({v,tmp});
            }
        }
    }
}


endsnippet
